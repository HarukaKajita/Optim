using System;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEditor.IMGUI.Controls;
using UnityEngine;

namespace Optim.MaterialViewer.Editor
{
    // SceneMaterialsWindow は現在シーンに存在する全てのマテリアルを一覧表示するウィンドウです。
    // 各マテリアルの詳細情報を確認し、シーン上での利用状況を簡単に調査できます。
    internal class SceneMaterialsWindow : EditorWindow
    {
        // 各マテリアルの使用状況を保持するための簡易データ構造
        private class MaterialInfo
        {
            // 参照しているマテリアル本体
            public Material Material;
            // いくつのサブメッシュから使用されているか
            public int SubMeshCount;
            // 使用しているRendererの一覧
            public HashSet<Renderer> Renderers = new();
            // 静的オブジェクトから使用されているか
            public bool UsedStatic;
            // 動的オブジェクトから使用されているか
            public bool UsedDynamic;
        }

        // 一覧表示を行うための TreeView 実装
        private class MaterialTreeView : TreeView
        {
            // 表示対象となるマテリアル情報のリスト
            private readonly List<MaterialInfo> items;
            // ヘッダー管理用
            private readonly MultiColumnHeader header;
            // 選択が変更された際に通知するイベント
            public event Action<MaterialInfo> OnSelectionChanged;

            // コンストラクタ。TreeView の初期設定を行う
            public MaterialTreeView(TreeViewState state, MultiColumnHeader header, List<MaterialInfo> items)
                : base(state, header)
            {
                this.items = items;
                this.header = header;
                rowHeight = EditorGUIUtility.singleLineHeight + 2f;
                showAlternatingRowBackgrounds = true;
                Reload();
            }

            // ルート要素の生成
            protected override TreeViewItem BuildRoot()
            {
                var root = new TreeViewItem { id = 0, depth = -1, displayName = "root" };
                var all = new List<TreeViewItem>();
                for (int i = 0; i < items.Count; ++i)
                {
                    all.Add(new TreeViewItem { id = i + 1, depth = 0, displayName = items[i].Material.name });
                }
                SetupParentsAndChildrenFromDepths(root, all);
                return root;
            }

            // 各行の描画処理
            protected override void RowGUI(RowGUIArgs args)
            {
                var item = items[args.item.id - 1];
                for (int i = 0; i < args.GetNumVisibleColumns(); ++i)
                {
                    Rect rect = args.GetCellRect(i);
                    CenterRectUsingSingleLineHeight(ref rect);
                    int col = args.GetColumn(i);
                    switch (col)
                    {
                        case 0:
                            EditorGUI.LabelField(rect, item.Material.name);
                            break;
                        case 1:
                            EditorGUI.LabelField(rect, item.SubMeshCount.ToString());
                            break;
                        case 2:
                            EditorGUI.LabelField(rect, item.Material.shader != null ? item.Material.shader.name : "");
                            break;
                        case 3:
                            EditorGUI.LabelField(rect, item.Material.renderQueue.ToString());
                            break;
                        case 4:
                            EditorGUI.LabelField(rect, item.Material.enableInstancing ? "On" : "Off");
                            break;
                        case 5:
                            EditorGUI.LabelField(rect, GetStaticState(item));
                            break;
                        case 6:
                            EditorGUI.LabelField(rect, item.Material.shaderKeywords.Length.ToString());
                            break;
                        case 7:
                            EditorGUI.LabelField(rect, GetZWrite(item.Material));
                            break;
                        case 8:
                            EditorGUI.LabelField(rect, GetCull(item.Material));
                            break;
                        case 9:
                            EditorGUI.LabelField(rect, GetBlend(item.Material));
                            break;
                        case 10:
                            EditorGUI.LabelField(rect, GetSRPBatching(item.Material));
                            break;
                    }
                }
            }

            // 行選択が変更された際に呼び出される
            protected override void SelectionChanged(IList<int> selectedIds)
            {
                if (selectedIds.Count > 0)
                    OnSelectionChanged?.Invoke(items[selectedIds[0] - 1]);
                else
                    OnSelectionChanged?.Invoke(null);
            }

            // ダブルクリック時に対象のマテリアルをピン留めする
            protected override void DoubleClickedItem(int id)
            {
                var info = items[id - 1];
                EditorGUIUtility.PingObject(info.Material);
                Selection.activeObject = info.Material;
            }

            // ヘッダークリックによるソート処理
            protected void SortByMultipleColumns()
            {
                if (items.Count == 0)
                    return;

                var columns = header.state.sortedColumns;
                Comparison<MaterialInfo> comparison = (a, b) => 0;
                foreach (var col in columns)
                {
                    bool asc = header.IsSortedAscending(col);
                    comparison = Combine(comparison, GetCompare(col, asc));
                }
                items.Sort(comparison);
                Reload();
            }

            // 複数の比較処理を連結するユーティリティ
            private static Comparison<MaterialInfo> Combine(Comparison<MaterialInfo> a, Comparison<MaterialInfo> b)
            {
                return (x, y) =>
                {
                    int res = a(x, y);
                    return res != 0 ? res : b(x, y);
                };
            }

            // 列ごとの比較関数を取得
            private static Comparison<MaterialInfo> GetCompare(int column, bool asc)
            {
                int Sign(int r) => asc ? r : -r;
                return column switch
                {
                    0 => (a, b) => Sign(string.Compare(a.Material.name, b.Material.name, StringComparison.OrdinalIgnoreCase)),
                    1 => (a, b) => Sign(a.SubMeshCount.CompareTo(b.SubMeshCount)),
                    2 => (a, b) => Sign(string.Compare(a.Material.shader?.name, b.Material.shader?.name, StringComparison.OrdinalIgnoreCase)),
                    3 => (a, b) => Sign(a.Material.renderQueue.CompareTo(b.Material.renderQueue)),
                    4 => (a, b) => Sign(a.Material.enableInstancing.CompareTo(b.Material.enableInstancing)),
                    5 => (a, b) => Sign(string.Compare(GetStaticState(a), GetStaticState(b), StringComparison.Ordinal)),
                    6 => (a, b) => Sign(a.Material.shaderKeywords.Length.CompareTo(b.Material.shaderKeywords.Length)),
                    7 => (a, b) => Sign(string.Compare(GetZWrite(a.Material), GetZWrite(b.Material), StringComparison.Ordinal)),
                    8 => (a, b) => Sign(string.Compare(GetCull(a.Material), GetCull(b.Material), StringComparison.Ordinal)),
                    9 => (a, b) => Sign(string.Compare(GetBlend(a.Material), GetBlend(b.Material), StringComparison.Ordinal)),
                    10 => (a, b) => Sign(string.Compare(GetSRPBatching(a.Material), GetSRPBatching(b.Material), StringComparison.Ordinal)),
                    _ => (x, y) => 0
                };
            }
        }

        private MaterialTreeView treeView;
        private MultiColumnHeader header;
        private SearchField searchField;
        private List<MaterialInfo> materials = new();
        private MaterialInfo selected;

        [MenuItem("Window/Scene Materials Viewer")]
        // メニューからウィンドウを開く
        private static void Open()
        {
            GetWindow<SceneMaterialsWindow>("Scene Materials");
        }

        // ウィンドウ有効化時に初期化を行う
        private void OnEnable()
        {
            Refresh();
        }

        // マテリアル情報を再収集し TreeView を再構築する
        private void Refresh()
        {
            CollectMaterials();
            var state = new TreeViewState();
            header = new MultiColumnHeader(CreateHeaderState());
            header.canSort = true;
            treeView = new MaterialTreeView(state, header, materials);
            header.sortingChanged += treeView.OnSortingChanged;
            treeView.OnSelectionChanged += info => selected = info;
            searchField = new SearchField();
        }

        // メインの描画処理
        private void OnGUI()
        {
            using (new EditorGUILayout.HorizontalScope(EditorStyles.toolbar))
            {
                if (GUILayout.Button("Refresh", EditorStyles.toolbarButton))
                {
                    Refresh();
                }
                GUILayout.FlexibleSpace();
                treeView.searchString = searchField.OnToolbarGUI(treeView.searchString);
            }

            Rect rect = new Rect(0, 20, position.width, position.height - 20);
            float detailWidth = 250f;
            Rect left = new Rect(rect.x, rect.y, detailWidth, rect.height);
            Rect right = new Rect(rect.x + detailWidth, rect.y, rect.width - detailWidth, rect.height);

            DrawDetailPane(left);
            treeView.OnGUI(right);
        }

        // 右側に表示する詳細ペインの描画
        private void DrawDetailPane(Rect rect)
        {
            GUILayout.BeginArea(rect, EditorStyles.helpBox);
            if (selected != null)
            {
                EditorGUILayout.LabelField(selected.Material.name, EditorStyles.boldLabel);
                EditorGUILayout.Space();
                EditorGUILayout.LabelField("Keywords:");
                foreach (var kw in selected.Material.shaderKeywords.OrderBy(k => k))
                {
                    EditorGUILayout.LabelField("  " + kw);
                }
                EditorGUILayout.Space();
                EditorGUILayout.LabelField("Used By:");
                foreach (var r in selected.Renderers)
                {
                    EditorGUILayout.ObjectField(r.gameObject.name, r, typeof(Renderer), true);
                }
            }
            else
            {
                GUILayout.Label("No material selected");
            }
            GUILayout.EndArea();
        }

        // シーン内の全 Renderer からマテリアルを収集する
        private void CollectMaterials()
        {
            materials.Clear();
            var renderers = FindObjectsOfType<Renderer>(true);
            var dict = new Dictionary<Material, MaterialInfo>();
            foreach (var r in renderers)
            {
                bool isStatic = r.gameObject.isStatic;
                var mats = r.sharedMaterials;
                for (int i = 0; i < mats.Length; ++i)
                {
                    var m = mats[i];
                    if (m == null)
                        continue;
                    if (!dict.TryGetValue(m, out var info))
                    {
                        info = new MaterialInfo { Material = m };
                        dict[m] = info;
                    }
                    info.SubMeshCount++;
                    info.Renderers.Add(r);
                    if (isStatic) info.UsedStatic = true; else info.UsedDynamic = true;
                }
            }
            materials.AddRange(dict.Values);
        }

        // TreeView のヘッダー定義を作成
        private static MultiColumnHeaderState CreateHeaderState()
        {
            var columns = new[]
            {
                new MultiColumnHeaderState.Column {headerContent = new GUIContent("Name"), width = 150, minWidth = 100, allowToggleVisibility = true},
                new MultiColumnHeaderState.Column {headerContent = new GUIContent("SubMeshes"), width = 70, minWidth = 50, allowToggleVisibility = true},
                new MultiColumnHeaderState.Column {headerContent = new GUIContent("Shader"), width = 150, minWidth = 100, allowToggleVisibility = true},
                new MultiColumnHeaderState.Column {headerContent = new GUIContent("Queue"), width = 60, minWidth = 50, allowToggleVisibility = true},
                new MultiColumnHeaderState.Column {headerContent = new GUIContent("Instancing"), width = 70, minWidth = 60, allowToggleVisibility = true},
                new MultiColumnHeaderState.Column {headerContent = new GUIContent("Static"), width = 60, minWidth = 50, allowToggleVisibility = true},
                new MultiColumnHeaderState.Column {headerContent = new GUIContent("Keywords"), width = 70, minWidth = 60, allowToggleVisibility = true},
                new MultiColumnHeaderState.Column {headerContent = new GUIContent("ZWrite"), width = 60, minWidth = 50, allowToggleVisibility = true},
                new MultiColumnHeaderState.Column {headerContent = new GUIContent("Cull"), width = 60, minWidth = 50, allowToggleVisibility = true},
                new MultiColumnHeaderState.Column {headerContent = new GUIContent("Blend"), width = 80, minWidth = 60, allowToggleVisibility = true},
                new MultiColumnHeaderState.Column {headerContent = new GUIContent("SRP"), width = 60, minWidth = 50, allowToggleVisibility = true}
            };
            return new MultiColumnHeaderState(columns);
        }

        // ZWrite 設定を取得
        private static string GetZWrite(Material mat)
        {
            if (mat.HasProperty("_ZWrite"))
                return mat.GetInt("_ZWrite") != 0 ? "On" : "Off";
            return "";
        }

        // カリングモードを取得
        private static string GetCull(Material mat)
        {
            if (mat.HasProperty("_Cull"))
            {
                int c = mat.GetInt("_Cull");
                return ((UnityEngine.Rendering.CullMode)c).ToString();
            }
            return "";
        }

        // ブレンドモードを取得
        private static string GetBlend(Material mat)
        {
            if (mat.HasProperty("_SrcBlend") && mat.HasProperty("_DstBlend"))
            {
                var src = (UnityEngine.Rendering.BlendMode)mat.GetInt("_SrcBlend");
                var dst = (UnityEngine.Rendering.BlendMode)mat.GetInt("_DstBlend");
                return $"{src}/{dst}";
            }
            return "";
        }

        // SRP Batching の互換性を確認
        private static string GetSRPBatching(Material mat)
        {
#if UNITY_EDITOR
            return "-";
            // var code = UnityEditor.Rendering.ShaderUtil.GetSRPBatcherCompatibilityCode(mat.shader);
            // return code == UnityEditor.Rendering.ShaderUtil.SRPBatcherCompatibilityCode.SRPBatcherCompatible ? "Compatible" : "Not";
#else
            return "";
#endif
        }

        // 静的・動的の使用状況を文字列化
        private static string GetStaticState(MaterialInfo info)
        {
            if (info.UsedStatic && info.UsedDynamic)
                return "Mixed";
            if (info.UsedStatic)
                return "Static";
            return "Dynamic";
        }
    }
}
